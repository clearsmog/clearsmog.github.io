[{"id":0,"href":"/docs/algorithms/","title":"Algorithms","section":"Docs","content":" 数据结构与算法 # 基础算法 # 数据结构 # "},{"id":1,"href":"/docs/cpp/basic/","title":"Basic","section":"Cpp","content":" 基础 # 语法 # 面向对象 # 1234\n"},{"id":2,"href":"/docs/algorithms/basic_algorithm/","title":"Basic Algorithm","section":"Algorithms","content":" 基础算法 # 快速排序 # void quick_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r \u0026gt;\u0026gt; 1]; while (i \u0026lt; j) { do i ++ ; while (q[i] \u0026lt; x); do j -- ; while (q[j] \u0026gt; x); if (i \u0026lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } 归并排序 # void merge_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int mid = l + r \u0026gt;\u0026gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) if (q[i] \u0026lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i \u0026lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j \u0026lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i \u0026lt;= r; i ++, j ++ ) q[i] = tmp[j]; } 整数二分 # bool check(int x) {/* ... */} // 检查x是否满足某种性质 // 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用： int bsearch_1(int l, int r) { while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1; } return l; } // 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用： int bsearch_2(int l, int r) { while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } 浮点数二分 # bool check(double x) {/* ... */} // 检查x是否满足某种性质 double bsearch_3(double l, double r) { const double eps = 1e-6; // eps 表示精度，取决于题目对精度的要求 while (r - l \u0026gt; eps) { double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; } return l; } 高精度加法 # // C = A + B, A \u0026gt;= 0, B \u0026gt;= 0 vector\u0026lt;int\u0026gt; add(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt; \u0026amp;B) { if (A.size() \u0026lt; B.size()) return add(B, A); vector\u0026lt;int\u0026gt; C; int t = 0; for (int i = 0; i \u0026lt; A.size(); i ++ ) { t += A[i]; if (i \u0026lt; B.size()) t += B[i]; C.push_back(t % 10); t /= 10; } if (t) C.push_back(t); return C; } "},{"id":3,"href":"/docs/algorithms/data_structure/","title":"Data Structure","section":"Algorithms","content":" 数据结构 # 单链表 # // head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点 int head, e[N], ne[N], idx; // 初始化 void init() { head = -1; idx = 0; } // 在链表头插入一个数a void insert(int a) { e[idx] = a, ne[idx] = head, head = idx ++ ; } // 将头结点删除，需要保证头结点存在 void remove() { head = ne[head]; } 双链表 # // e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点 int e[N], l[N], r[N], idx; // 初始化 void init() { //0是左端点，1是右端点 r[0] = 1, l[1] = 0; idx = 2; } // 在节点a的右边插入一个数x void insert(int a, int x) { e[idx] = x; l[idx] = a, r[idx] = r[a]; l[r[a]] = idx, r[a] = idx ++ ; } // 删除节点a void remove(int a) { l[r[a]] = l[a]; r[l[a]] = r[a]; } 栈 # // tt表示栈顶 int stk[N], tt = 0; // 向栈顶插入一个数 stk[ ++ tt] = x; // 从栈顶弹出一个数 tt -- ; // 栈顶的值 stk[tt]; // 判断栈是否为空 if (tt \u0026gt; 0) { } 队列 # // hh 表示队头，tt表示队尾 int q[N], hh = 0, tt = -1; // 向队尾插入一个数 q[ ++ tt] = x; // 从队头弹出一个数 hh ++ ; // 队头的值 q[hh]; // 判断队列是否为空 if (hh \u0026lt;= tt) { } "},{"id":4,"href":"/docs/cpp/project/","title":"Project","section":"Cpp","content":" 项目 # 描述 # 实现 # "},{"id":5,"href":"/docs/cpp/","title":"Cpp","section":"Docs","content":" c++ # 基础 # 项目 # "},{"id":6,"href":"/docs/linux/","title":"Linux","section":"Docs","content":" Linux教程 # neovim使用 # grep命令 # arch 安装 # "},{"id":7,"href":"/posts/sembawang/","title":"骑行Sembawang","section":"Blog","content":"Sembawang 位于中北部，在动物园的西北方向\n岛上唯一开放的天然温泉 温泉蛋 码头上的钓鱼者 傍晚游泳的人 眺望对面的女子 "},{"id":8,"href":"/posts/kranji/","title":"骑行Kranji","section":"Blog","content":"到达时间上午，从裕廊西骑过去大概一个小时。 蓄水池地图 清晨的星马海峡 "},{"id":9,"href":"/docs/linux/grep/","title":"Grep","section":"Linux","content":" grep命令 # 作用 # 查找文件中符合要求的字符串。\n实例 # grep test *file 在当前目录中查找后缀有file的文件中包含test字符串的文件。\ngrep -r update /etc/acpi 以递归的方式查找，指定查找目录为\u0026quot;/etc/acpi\u0026quot;\ngrep -v test *test* 反向查找，\u0026quot;-v\u0026quot; 参赛用于打印出不符合条件行的内容。\n"},{"id":10,"href":"/docs/linux/neovim/","title":"Neovim","section":"Linux","content":" neovim # vim教程 # 参考 VimTutor\n现成配置框架 # LunarVim\nNVchad\nAstroNvim\n"}]